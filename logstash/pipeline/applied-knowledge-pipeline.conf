# Logstash Pipeline: Applied Knowledge (CORE ENTITY)
# Syncs Applied Knowledge assignments from PostgreSQL to Elasticsearch
# This is the core business data that connects projects, pragmatics, and knowledge

input {
  jdbc {
    jdbc_driver_library => "/usr/share/logstash/drivers/postgresql-42.7.1.jar"
    jdbc_driver_class => "org.postgresql.Driver"
    jdbc_connection_string => "jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}"
    jdbc_user => "${POSTGRES_USER}"
    jdbc_password => "${POSTGRES_PASSWORD}"

    # Run every 30 seconds for near real-time sync (core data)
    schedule => "*/30 * * * * *"

    # Track last sync to only get updates
    use_column_value => true
    tracking_column => "updated_at"
    tracking_column_type => "timestamp"
    last_run_metadata_path => "/usr/share/logstash/data/.logstash_jdbc_last_run_applied_knowledge"

    # Comprehensive SQL Query with all related entities
    statement => "
      SELECT
        ak.id,
        ak.project_id,
        p.name as project_name,
        p.status as project_status,
        p.account_id,
        a.name as account_name,
        a.territory_id,
        t.name as territory_name,
        ak.pragmatic_id,
        pr.first_name as pragmatic_first_name,
        pr.last_name as pragmatic_last_name,
        pr.email as pragmatic_email,
        pr.chapter_id,
        ch.name as chapter_name,
        ch.kc_id,
        kc.name as kc_team_name,
        ak.knowledge_id,
        k.name as knowledge_name,
        k.description as knowledge_description,
        k.category_id,
        cat.name as knowledge_category_name,
        ak.knowledge_level,
        kl.name as knowledge_level_name,
        kl.attributes as knowledge_level_attributes,
        ak.onboard_date,
        ak.offboard_date,
        ak.attributes,
        ak.created_at,
        ak.updated_at
      FROM \"Applied_Knowledge\" ak
      INNER JOIN \"Project\" p ON ak.project_id = p.id
      INNER JOIN \"Account\" a ON p.account_id = a.id
      LEFT JOIN \"territory\" t ON a.territory_id = t.id
      INNER JOIN \"Pragmatic\" pr ON ak.pragmatic_id = pr.id
      INNER JOIN \"Chapter\" ch ON pr.chapter_id = ch.id
      INNER JOIN \"KC-Team\" kc ON ch.kc_id = kc.id
      INNER JOIN \"knowledge\" k ON ak.knowledge_id = k.id
      INNER JOIN \"Knowledge_Category\" cat ON k.category_id = cat.id
      INNER JOIN \"Knowledge_Level\" kl ON ak.knowledge_level = kl.id
      WHERE ak.updated_at > :sql_last_value
      ORDER BY ak.updated_at ASC
    "

    clean_run => false
    lowercase_column_names => false
  }
}

filter {
  # Parse JSON attributes if present
  if [attributes] {
    json {
      source => "attributes"
      target => "attributes_parsed"
      skip_on_invalid_json => true
    }
  }

  # Parse knowledge level attributes
  if [knowledge_level_attributes] {
    json {
      source => "knowledge_level_attributes"
      target => "knowledge_level_attributes_parsed"
      skip_on_invalid_json => true
    }
  }

  # Create composite fields for better searching
  mutate {
    add_field => {
      "pragmatic_full_name" => "%{pragmatic_first_name} %{pragmatic_last_name}"
    }
  }

  # Calculate assignment duration in days
  if [onboard_date] {
    ruby {
      code => "
        onboard = Date.parse(event.get('onboard_date'))
        offboard = event.get('offboard_date')

        if offboard && !offboard.empty?
          offboard_date = Date.parse(offboard)
          duration = (offboard_date - onboard).to_i
          event.set('assignment_duration_days', duration)
          event.set('is_currently_assigned', false)
        else
          # Still active - calculate from onboard to today
          duration = (Date.today - onboard).to_i
          event.set('assignment_duration_days', duration)
          event.set('is_currently_assigned', true)
        end
      "
    }
  }

  # Determine assignment status
  ruby {
    code => "
      offboard_date = event.get('offboard_date')
      project_status = event.get('project_status')

      if offboard_date && !offboard_date.empty?
        event.set('assignment_status', 'completed')
      elsif project_status == 'Active'
        event.set('assignment_status', 'active')
      else
        event.set('assignment_status', 'inactive')
      end
    "
  }

  # Add metadata
  mutate {
    add_field => {
      "[@metadata][index]" => "applied-knowledge"
      "[@metadata][document_id]" => "%{id}"
      "entity_type" => "applied_knowledge"
      "sync_timestamp" => "%{@timestamp}"
    }
    remove_field => ["@version"]
  }

  # Convert timestamps
  date {
    match => ["created_at", "ISO8601", "yyyy-MM-dd HH:mm:ss.SSS"]
    target => "created_at"
  }

  date {
    match => ["updated_at", "ISO8601", "yyyy-MM-dd HH:mm:ss.SSS"]
    target => "updated_at"
  }

  date {
    match => ["onboard_date", "ISO8601", "yyyy-MM-dd"]
    target => "onboard_date"
  }

  if [offboard_date] {
    date {
      match => ["offboard_date", "ISO8601", "yyyy-MM-dd"]
      target => "offboard_date"
    }
  }
}

output {
  elasticsearch {
    hosts => ["${ELASTICSEARCH_HOSTS}"]
    index => "applied-knowledge-%{+YYYY.MM}"
    document_id => "%{[@metadata][document_id]}"
    action => "index"
  }

  # Debug output (optional)
  stdout {
    codec => rubydebug {
      metadata => false
    }
  }
}
