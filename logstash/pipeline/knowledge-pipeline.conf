# Logstash Pipeline: Knowledge
# Syncs Knowledge catalog data from PostgreSQL to Elasticsearch

input {
  jdbc {
    jdbc_driver_library => "/usr/share/logstash/drivers/postgresql-42.7.1.jar"
    jdbc_driver_class => "org.postgresql.Driver"
    jdbc_connection_string => "jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}"
    jdbc_user => "${POSTGRES_USER}"
    jdbc_password => "${POSTGRES_PASSWORD}"

    # Run every 60 seconds (knowledge catalog changes less frequently)
    schedule => "*/60 * * * * *"

    # Track by ID since knowledge may not have updated_at
    use_column_value => true
    tracking_column => "id"
    tracking_column_type => "numeric"
    last_run_metadata_path => "/usr/share/logstash/data/.logstash_jdbc_last_run_knowledge"

    # SQL Query with category and usage statistics
    statement => "
      SELECT
        k.id,
        k.category_id,
        kc.name as category_name,
        k.name,
        k.description,
        k.approved_status,
        k.attributes,
        COUNT(DISTINCT ak.pragmatic_id) as times_applied,
        COUNT(DISTINCT ak.project_id) as projects_using,
        array_agg(DISTINCT p.name) as project_names
      FROM \"knowledge\" k
      INNER JOIN \"Knowledge_Category\" kc ON k.category_id = kc.id
      LEFT JOIN \"Applied_Knowledge\" ak ON ak.knowledge_id = k.id
      LEFT JOIN \"Project\" p ON ak.project_id = p.id
      WHERE k.id > :sql_last_value
      GROUP BY k.id, kc.name
      ORDER BY k.id ASC
    "

    clean_run => false
    lowercase_column_names => false
  }
}

filter {
  # Parse JSON attributes if present
  if [attributes] {
    json {
      source => "attributes"
      target => "attributes_parsed"
      skip_on_invalid_json => true
    }
  }

  # Calculate popularity score based on usage
  ruby {
    code => "
      times_applied = event.get('times_applied').to_i
      projects_using = event.get('projects_using').to_i

      # Simple popularity score: weighted sum
      popularity_score = (times_applied * 2) + (projects_using * 5)
      event.set('popularity_score', popularity_score)

      # Determine popularity tier
      if popularity_score >= 50
        event.set('popularity_tier', 'high')
      elsif popularity_score >= 20
        event.set('popularity_tier', 'medium')
      elsif popularity_score > 0
        event.set('popularity_tier', 'low')
      else
        event.set('popularity_tier', 'unused')
      end
    "
  }

  # Add metadata
  mutate {
    add_field => {
      "[@metadata][index]" => "knowledge"
      "[@metadata][document_id]" => "%{id}"
      "entity_type" => "knowledge"
      "sync_timestamp" => "%{@timestamp}"
    }
    remove_field => ["@version"]
  }
}

output {
  elasticsearch {
    hosts => ["${ELASTICSEARCH_HOSTS}"]
    index => "knowledge"
    document_id => "%{[@metadata][document_id]}"
    action => "index"
  }

  # Debug output (optional)
  stdout {
    codec => rubydebug {
      metadata => false
    }
  }
}
